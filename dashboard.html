<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Workplace Scheduler Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f8f9fa;
            color: #333;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .header h1 {
            font-size: 1.5rem;
            font-weight: 600;
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .admin-badge {
            background: #28a745;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.8rem;
            display: none;
        }

        .user-badge {
            background: #17a2b8;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.8rem;
            display: none;
        }

        .logout-btn {
            background: rgba(255,255,255,0.2);
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .logout-btn:hover {
            background: rgba(255,255,255,0.3);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }

        .workplace-section, .admin-section {
            background: white;
            border-radius: 15px;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
        }

        .admin-section {
            border: 2px solid #28a745;
        }

        .section-title {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 1.5rem;
            color: #333;
        }

        .admin-title {
            color: #28a745;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .workplace-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .workplace-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 1.5rem;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            text-align: center;
        }

        .workplace-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
        }

        .workplace-card.selected {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            transform: translateY(-4px);
            box-shadow: 0 8px 25px rgba(40, 167, 69, 0.3);
        }

        .workplace-card h4 {
            font-size: 1.1rem;
            margin-bottom: 0.5rem;
        }

        .workplace-card p {
            opacity: 0.9;
            font-size: 0.9rem;
        }

        .schedule-content {
            display: none;
        }

        .action-buttons, .admin-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s ease;
            text-decoration: none;
            display: inline-block;
            text-align: center;
            position: relative;
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn-primary { background: #007bff; color: white; }
        .btn-success { background: #28a745; color: white; }
        .btn-info { background: #17a2b8; color: white; }
        .btn-warning { background: #ffc107; color: #212529; }
        .btn-danger { background: #dc3545; color: white; }
        .btn-secondary { background: #6c757d; color: white; }
        .btn-admin { background: #28a745; color: white; }

        .btn:hover:not(:disabled) { 
            transform: translateY(-1px); 
            filter: brightness(1.1);
        }

        .btn.loading::after {
            content: "";
            position: absolute;
            width: 16px;
            height: 16px;
            margin: auto;
            border: 2px solid transparent;
            border-top-color: #ffffff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .form-section {
            background: #f8f9fa;
            padding: 2rem;
            border-radius: 12px;
            margin-bottom: 2rem;
            border: 2px solid #e9ecef;
            display: none;
        }

        .form-group {
            margin-bottom: 1.5rem;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: #555;
        }

        .form-group input, .form-group select, .form-group textarea {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s ease;
        }

        .form-group input:focus, .form-group select:focus, .form-group textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        }

        .form-row-3 {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 1rem;
        }

        .hours-grid {
            display: grid;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .day-hours {
            background: white;
            padding: 1rem;
            border-radius: 8px;
            border: 2px solid #e9ecef;
        }

        .day-hours h5 {
            margin-bottom: 0.5rem;
            color: #333;
        }

        .schedule-display {
            background: white;
            border-radius: 12px;
            padding: 2rem;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 1.5rem;
            border-radius: 12px;
            text-align: center;
        }

        .stat-number {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
        }

        .stat-label {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .day-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 1rem;
            border-radius: 8px;
            font-weight: 600;
            margin: 1.5rem 0 1rem 0;
            text-align: center;
        }

        .shift {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 0.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .shift.work-study {
            border-color: #ffc107;
            background: #fff8e1;
        }

        .shift.unfilled {
            border-color: #dc3545;
            background: #ffebee;
        }

        .shift.coverage-gap {
            border-color: #ff5722;
            background: #ffebee;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 87, 34, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(255, 87, 34, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 87, 34, 0); }
        }

        .shift-actions {
            display: flex;
            gap: 0.5rem;
        }

        .shift-actions .btn {
            padding: 0.25rem 0.5rem;
            font-size: 0.8rem;
        }

        .worker-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }

        .worker-table th, .worker-table td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid #dee2e6;
        }

        .worker-table th {
            background: #f8f9fa;
            font-weight: 600;
            color: #495057;
        }

        .worker-table tr:hover {
            background: #f8f9fa;
        }

        .worker-actions {
            display: flex;
            gap: 0.5rem;
        }

        .worker-actions .btn {
            padding: 0.25rem 0.5rem;
            font-size: 0.8rem;
        }

        .loading {
            text-align: center;
            padding: 3rem;
            color: #667eea;
            font-size: 1.1rem;
        }

        .warning {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
        }

        .success {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
        }

        .error {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
        }

        .info {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            color: #0c5460;
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }

        .modal-content {
            background-color: white;
            margin: 5% auto;
            padding: 2rem;
            border-radius: 12px;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .close {
            font-size: 2rem;
            cursor: pointer;
            color: #999;
        }

        .close:hover {
            color: #333;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin: 1rem 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.3s ease;
        }

        .print-only {
            display: none;
        }

        @media print {
            .no-print { display: none !important; }
            .print-only { display: block !important; }
            .schedule-display { box-shadow: none; }
            .btn { display: none !important; }
            .shift-actions { display: none !important; }
            body { background: white; }
            .header { background: #333 !important; }
        }

        @media (max-width: 768px) {
            .container { padding: 1rem; }
            .workplace-grid { grid-template-columns: 1fr; }
            .action-buttons, .admin-buttons { flex-direction: column; }
            .form-row, .form-row-3 { grid-template-columns: 1fr; }
            .stats { grid-template-columns: 1fr; }
            .modal-content { margin: 10% auto; width: 95%; }
        }

        .shift.forced-shift {
            border: 2.5px solid #e53935 !important;
            box-shadow: 0 0 0 2px #e5393533 !important;
            position: relative;
        }
        .shift.forced-shift::after {
            content: "!";
            color: #e53935;
            font-weight: bold;
            position: absolute;
            top: 8px;
            right: 12px;
            font-size: 1.2rem;
            background: #fff;
            border-radius: 50%;
            border: 1.5px solid #e53935;
            width: 22px;
            height: 22px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2;
        }
    </style>
</head>

<body>
    <div class="header">
        <h1>üè¢ Workplace Scheduler</h1>
        <div class="user-info">
            <span id="userEmail"></span>
            <span id="adminBadge" class="admin-badge">ADMIN</span>
            <span id="userBadge" class="user-badge">USER</span>
            <button class="logout-btn" onclick="logout()">Logout</button>
        </div>
    </div>

    <div class="container">
        <!-- Admin Controls -->
        <div id="adminSection" class="admin-section" style="display: none;">
            <h2 class="section-title admin-title">üîß Admin Controls</h2>
            <div class="admin-buttons">
                <button class="btn btn-admin" onclick="showManageHours()">‚è∞ Manage Hours</button>
                <button class="btn btn-admin" onclick="showManageWorkers()">üë• Manage Workers</button>
                <button class="btn btn-admin" onclick="showAddWorker()">‚ûï Add Worker</button>
            </div>
        </div>

        <!-- Workplace Selection -->
        <div class="workplace-section">
            <h2 class="section-title">Select Workplace</h2>
            <div class="workplace-grid" id="workplaceGrid">
                <div class="workplace-card" onclick="selectWorkplace('esports_lounge')">
                    <h4>üéÆ eSports Lounge</h4>
                    <p>esports_lounge</p>
                </div>
                <div class="workplace-card" onclick="selectWorkplace('esports_arena')">
                    <h4>üèüÔ∏è eSports Arena</h4>
                    <p>esports_arena</p>
                </div>
                <div class="workplace-card" onclick="selectWorkplace('it_service_center')">
                    <h4>üíª IT Service Center</h4>
                    <p>it_service_center</p>
                </div>
            </div>
        </div>

        <!-- Schedule Management -->
        <div class="schedule-content" id="scheduleContent">
            <div class="workplace-section">
                <h2 class="section-title">Schedule Management</h2>
                
                <div class="action-buttons">
                    <button class="btn btn-primary" onclick="showGenerateForm()" id="generateBtn">üìÖ Generate New Schedule</button>
                    <button class="btn btn-success" onclick="viewCurrentSchedule()">üëÅÔ∏è View Current Schedule</button>
                    <button class="btn btn-info" onclick="viewHistory()">üìö Schedule History</button>
                    <button class="btn btn-warning" onclick="checkAvailability()">üîç Check Availability</button>
                    <button class="btn btn-secondary" onclick="viewWorkers()">üë• View Workers</button>
                    <button class="btn btn-warning" onclick="showLastMinuteCheck()" id="lastMinuteBtn">üö® Last Minute</button>
                </div>

                <!-- Generate Schedule Form -->
                <div class="form-section" id="generateForm">
                    <h3>Generate New Schedule</h3>
                    <div class="info">
                        <strong>üí° Schedule Generation Tips:</strong><br>
                        ‚Ä¢ Work study students automatically get exactly 5 hours<br>
                        ‚Ä¢ Algorithm ensures all operating hours are covered<br>
                        ‚Ä¢ Fair distribution based on worker availability<br>
                        ‚Ä¢ Unfilled shifts will be highlighted for attention
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label for="maxHours">Max Hours per Worker</label>
                            <input type="number" id="maxHours" value="20" min="5" max="40">
                        </div>
                        <div class="form-group">
                            <label for="workersPerShift">Workers per Shift</label>
                            <input type="number" id="workersPerShift" value="2" min="1" max="5">
                        </div>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label for="minHours">Min Hours per Worker</label>
                            <input type="number" id="minHours" value="3" min="0" max="20">
                        </div>
                        <div class="form-group">
                            <label for="scheduleVariation">Schedule Variation</label>
                            <select id="scheduleVariation">
                                <option value="balanced">Balanced Distribution</option>
                                <option value="random">Random Assignment</option>
                                <option value="work_study_first">Work Study Priority</option>
                                <option value="fair_rotation">Fair Rotation</option>
                            </select>
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="shiftLength">Preferred Shift Length</label>
                        <select id="shiftLength">
                            <option value="flexible">Flexible (2-4 hours)</option>
                            <option value="short">Short (2-3 hours)</option>
                            <option value="long">Long (3-4 hours)</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>
                            <input type="checkbox" id="ensureFullCoverage" checked>
                            Ensure complete coverage of all operating hours
                        </label>
                    </div>
                    <button class="btn btn-success" onclick="generateSchedule()" id="generateScheduleBtn">üöÄ Generate Schedule</button>
                    <button class="btn btn-secondary" onclick="hideAllForms()">Cancel</button>
                </div>

                <!-- Check Availability Form -->
                <div class="form-section" id="availabilityForm">
                    <h3>Check Worker Availability</h3>
                    <div class="form-row">
                        <div class="form-group">
                            <label for="availDay">Day</label>
                            <select id="availDay">
                                <option value="Monday">Monday</option>
                                <option value="Tuesday">Tuesday</option>
                                <option value="Wednesday">Wednesday</option>
                                <option value="Thursday">Thursday</option>
                                <option value="Friday">Friday</option>
                                <option value="Saturday">Saturday</option>
                                <option value="Sunday">Sunday</option>
                            </select>
                        </div>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label for="availStart">Start Time</label>
                            <input type="time" id="availStart">
                        </div>
                        <div class="form-group">
                            <label for="availEnd">End Time</label>
                            <input type="time" id="availEnd">
                        </div>
                    </div>
                    <button class="btn btn-info" onclick="findAvailable()">üîç Find Available Workers</button>
                    <button class="btn btn-secondary" onclick="hideAllForms()">Cancel</button>
                </div>

                <!-- Schedule Display -->
                <div id="scheduleDisplay">
                    <div class="loading">Select an option above to get started.</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal for Manage Hours -->
    <div id="hoursModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>‚è∞ Manage Hours of Operation</h3>
                <span class="close" onclick="closeModal('hoursModal')">&times;</span>
            </div>
            <div id="hoursModalContent">
                <div class="loading">Loading hours...</div>
            </div>
        </div>
    </div>

    <!-- Modal for Manage Workers -->
    <div id="workersModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>üë• Manage Workers</h3>
                <span class="close" onclick="closeModal('workersModal')">&times;</span>
            </div>
            <div id="workersModalContent">
                <div class="loading">Loading workers...</div>
            </div>
        </div>
    </div>

    <!-- Modal for Add/Edit Worker -->
    <div id="workerFormModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="workerFormTitle">‚ûï Add Worker</h3>
                <span class="close" onclick="closeModal('workerFormModal')">&times;</span>
            </div>
            <form id="workerForm">
                <div class="form-row">
                    <div class="form-group">
                        <label for="workerFirstName">First Name</label>
                        <input type="text" id="workerFirstName" required>
                    </div>
                    <div class="form-group">
                        <label for="workerLastName">Last Name</label>
                        <input type="text" id="workerLastName" required>
                    </div>
                </div>
                <div class="form-row">
                    <div class="form-group">
                        <label for="workerEmail">Email</label>
                        <input type="email" id="workerEmail" required>
                    </div>
                    <div class="form-group">
                        <label for="workerWorkStudy">Work Study</label>
                        <select id="workerWorkStudy">
                            <option value="No">No</option>
                            <option value="Yes">Yes</option>
                        </select>
                    </div>
                </div>
                <div class="form-group">
                    <label for="workerAvailability">Availability (e.g., "Mon 09:00-17:00, Tue 10:00-16:00")</label>
                    <textarea id="workerAvailability" rows="3" placeholder="Mon 09:00-17:00, Tue 10:00-16:00, Wed 08:00-14:00"></textarea>
                    <small style="color: #666; font-style: italic;">Format: Day HH:MM-HH:MM, Day HH:MM-HH:MM</small>
                </div>
                <div style="display: flex; gap: 1rem; margin-top: 1rem;">
                    <button type="submit" class="btn btn-success">üíæ Save Worker</button>
                    <button type="button" class="btn btn-secondary" onclick="closeModal('workerFormModal')">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Add a minimal modal to the HTML if not present -->
    <div id="editShiftModal" class="modal">
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-header">
                <h3>Edit Shift</h3>
                <span class="close" onclick="closeModal('editShiftModal')">&times;</span>
            </div>
            <div id="editShiftModalBody"></div>
        </div>
    </div>

    <script type="module">
        // Enhanced auth check and setup
        const user = JSON.parse(localStorage.getItem('user') || '{}');
        if (!user.email) {
            window.location.href = 'index.html';
        }
        
        document.getElementById('userEmail').textContent = user.email;
        if (user.isAdmin) {
            document.getElementById('adminBadge').style.display = 'inline';
            document.getElementById('adminSection').style.display = 'block';
            document.getElementById('userBadge').style.display = 'none';
        } else {
            document.getElementById('adminBadge').style.display = 'none';
            document.getElementById('userBadge').style.display = 'inline';
            // Hide admin-only buttons for non-admin users
            document.getElementById('generateBtn').style.display = 'none';
            document.getElementById('lastMinuteBtn').style.display = 'none';
        }

        // Firebase setup
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/11.10.0/firebase-app.js';
        import { 
            getFirestore, collection, getDocs, doc, getDoc, addDoc, updateDoc, deleteDoc, query, orderBy, setDoc
        } from 'https://www.gstatic.com/firebasejs/11.10.0/firebase-firestore.js';

        const workplaceConfig = {
            apiKey: "AIzaSyBkkq4nPnmyfSOKtVLsO95rpAUsMDA1o0A",
            authDomain: "workplace-scheduler-ace38.firebaseapp.com", 
            projectId: "workplace-scheduler-ace38",
            storageBucket: "workplace-scheduler-ace38.firebasestorage.app",
            messagingSenderId: "153631302747",
            appId: "1:153631302747:web:2c731351893dca19510b7e"
        };

        const workplaceApp = initializeApp(workplaceConfig);
        const db = getFirestore(workplaceApp);

        // Global state
        let selectedWorkplace = null;
        let workers = [];
        let hours = {};
        let editingWorkerId = null;
        let schedule = {};
        const DAYS = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];

        // Enhanced utility functions
        const timeToHour = (timeStr) => {
            if (!timeStr) return 0;
            const [h, m] = timeStr.split(':').map(Number);
            return h + (m / 60);
        };

        const hourToTime = (hour) => {
            const h = Math.floor(hour);
            const m = Math.round((hour - h) * 60);
            return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`;
        };

        const formatTime = (timeStr) => {
            if (!timeStr) return '';
            let [h, m] = timeStr.split(':').map(Number);
            const period = h >= 12 ? 'PM' : 'AM';
            h = h % 12 || 12;
            return `${h}:${m.toString().padStart(2, '0')} ${period}`;
        };

        // Enhanced availability parsing
        const parseAvailability = (availabilityText) => {
            const availability = {};
            if (!availabilityText) return availability;
            
            const dayMap = {
                'sunday': 'Sunday', 'sun': 'Sunday',
                'monday': 'Monday', 'mon': 'Monday',
                'tuesday': 'Tuesday', 'tue': 'Tuesday',
                'wednesday': 'Wednesday', 'wed': 'Wednesday',
                'thursday': 'Thursday', 'thu': 'Thursday',
                'friday': 'Friday', 'fri': 'Friday',
                'saturday': 'Saturday', 'sat': 'Saturday'
            };
            
            const blocks = availabilityText.split(',').map(s => s.trim());
            blocks.forEach(block => {
                const match = block.match(/(\w+)\s+(\d{1,2}:\d{2})-(\d{1,2}:\d{2})/i);
                if (match) {
                    const [, dayRaw, start, end] = match;
                    const day = dayMap[dayRaw.toLowerCase()];
                    
                    if (day) {
                        let startHour = timeToHour(start);
                        let endHour = timeToHour(end);
                        
                        if (endHour <= startHour) {
                            endHour += 24.0;
                        }
                        
                        if (!availability[day]) availability[day] = [];
                        
                        availability[day].push({
                            start: start,
                            end: end,
                            start_hour: startHour,
                            end_hour: endHour
                        });
                    }
                }
            });
            
            return availability;
        };

        const isWorkerAvailable = (worker, day, startHour, endHour) => {
            const dayAvail = worker.availability[day] || [];
            return dayAvail.some(slot => slot.start_hour <= startHour && endHour <= slot.end_hour);
        };

        // Enhanced loading state management
        const setLoading = (elementId, isLoading, originalText = '') => {
            const element = document.getElementById(elementId);
            if (!element) return;
            
            if (isLoading) {
                element.classList.add('loading');
                element.disabled = true;
                element.setAttribute('data-original-text', element.textContent);
                element.textContent = 'üîÑ Loading...';
            } else {
                element.classList.remove('loading');
                element.disabled = false;
                const original = element.getAttribute('data-original-text') || originalText;
                if (original) element.textContent = original;
            }
        };

        // Enhanced error handling
        const showNotification = (message, type = 'info') => {
            const notification = document.createElement('div');
            notification.className = `${type} notification`;
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                z-index: 10000;
                max-width: 400px;
                padding: 1rem;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                animation: slideIn 0.3s ease;
            `;
            notification.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <span>${message}</span>
                    <button onclick="this.parentElement.parentElement.remove()" style="background: none; border: none; font-size: 1.2rem; cursor: pointer; margin-left: 1rem;">&times;</button>
                </div>
            `;
            
            document.body.appendChild(notification);
            
            // Auto remove after 5 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.remove();
                }
            }, 5000);
        };

        // Enhanced schedule validation
        const validateScheduleCoverage = (schedule, hoursOfOperation) => {
            const coverageGaps = [];
            const warnings = [];
            
            for (const [day, hours] of Object.entries(hoursOfOperation)) {
                for (const hour of hours) {
                    const opStart = timeToHour(hour.start);
                    const opEnd = timeToHour(hour.end);
                    
                    // Check if this time period is covered by any shift
                    const dayShifts = schedule[day] || [];
                    const coveredPeriods = [];
                    
                    dayShifts.forEach(shift => {
                        if (!shift.assigned.includes('Unfilled')) {
                            const shiftStart = timeToHour(shift.start);
                            const shiftEnd = timeToHour(shift.end);
                            coveredPeriods.push([shiftStart, shiftEnd]);
                        }
                    });
                    
                    // Sort covered periods
                    coveredPeriods.sort((a, b) => a[0] - b[0]);
                    
                    // Find gaps
                    let currentTime = opStart;
                    for (const [start, end] of coveredPeriods) {
                        if (start > currentTime) {
                            // There's a gap
                            coverageGaps.push({
                                day,
                                start: hourToTime(currentTime),
                                end: hourToTime(start),
                                duration: start - currentTime
                            });
                        }
                        currentTime = Math.max(currentTime, end);
                    }
                    
                    // Check if there's a gap at the end
                    if (currentTime < opEnd) {
                        coverageGaps.push({
                            day,
                            start: hourToTime(currentTime),
                            end: hourToTime(opEnd),
                            duration: opEnd - currentTime
                        });
                    }
                }
            }
            
            return { coverageGaps, warnings };
        };

        // Utility functions
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        const calculateAvailabilityHours = (worker) => {
            let totalHours = 0;
            for (const daySlots of Object.values(worker.availability || {})) {
                for (const slot of daySlots) {
                    totalHours += slot.end_hour - slot.start_hour;
                }
            }
            return totalHours;
        };

        const findOptimalShiftSplit = (windows, remainingHours, preferSplit = true) => {
            if (!windows || remainingHours <= 0) {
                return [];
            }
            
            const totalAvailable = windows.reduce((sum, [day, start, end]) => sum + (end - start), 0);
            if (totalAvailable < remainingHours) {
                return windows.map(([day, start, end]) => [day, start, end, end - start]);
            }
            
            if (preferSplit && remainingHours === 5.0) {
                for (let i = 0; i < windows.length; i++) {
                    const [day1, s1, e1] = windows[i];
                    if (2.8 <= (e1 - s1) && (e1 - s1) <= 3.2) {
                        for (let j = 0; j < windows.length; j++) {
                            if (i !== j) {
                                const [day2, s2, e2] = windows[j];
                                if (1.8 <= (e2 - s2) && (e2 - s2) <= 2.2) {
                                    return [
                                        [day1, s1, s1 + 3.0, 3.0],
                                        [day2, s2, s2 + 2.0, 2.0]
                                    ];
                                }
                            }
                        }
                    }
                }
            }
            
            const result = [];
            let remaining = remainingHours;
            const sortedWindows = [...windows].sort((a, b) => (a[2] - a[1]) - (b[2] - b[1]));
            
            for (const [day, start, end] of sortedWindows) {
                if (remaining <= 0) break;
                
                const windowDuration = end - start;
                const take = Math.min(windowDuration, remaining);
                result.push([day, start, start + take, take]);
                remaining -= take;
            }
            
            return result;
        };

        const checkWorkStudyAvailability = (wsWorkers, hoursOfOperation) => {
            const issues = [];
            
            for (const worker of wsWorkers) {
                let matchingHours = 0;
                
                for (const [day, ops] of Object.entries(hoursOfOperation)) {
                    for (const op of ops) {
                        let opStart = timeToHour(op.start);
                        let opEnd = timeToHour(op.end);
                        if (opEnd <= opStart) opEnd += 24;
                        
                        for (const a of worker.availability[day] || []) {
                            const overlapStart = Math.max(opStart, a.start_hour);
                            const overlapEnd = Math.min(opEnd, a.end_hour);
                            if (overlapEnd > overlapStart) {
                                matchingHours += (overlapEnd - overlapStart);
                            }
                        }
                    }
                }
                
                if (matchingHours < 5) {
                    issues.push([
                        worker,
                        `Only ${matchingHours.toFixed(1)} hours available during operating hours (needs 5)`
                    ]);
                }
            }
            
            return issues;
        };

        // Logout function
        window.logout = function() {
            localStorage.removeItem('user');
            window.location.href = 'index.html';
        };

        // Enhanced scheduling algorithm with guaranteed coverage
        const createShiftsFromAvailability = (hoursOfOperation, workersData, maxHoursPerWorker = 20, maxWorkersPerShift = 2, minHoursPerWorker = 3, ensureFullCoverage = true) => {
            console.log('Starting enhanced schedule generation with full coverage:', { hoursOfOperation, workersData, maxHoursPerWorker, maxWorkersPerShift, minHoursPerWorker, ensureFullCoverage });
            
            if (!hoursOfOperation || !workersData || workersData.length === 0) {
                console.warn('Missing data for schedule generation');
                return { schedule: {}, assignedHours: {}, lowHours: [], unassigned: [], altSols: {}, unfilledShifts: [], wsIssues: [], minHoursIssues: [], coverageGaps: [] };
            }

            const schedule = {};
            const unfilledShifts = [];
            const shiftLengths = [2, 3, 4, 5];
            const shuffledLengths = shuffleArray(shiftLengths);
            const assignedHours = {};
            const wsStatus = {};
            const availabilityHours = {};
            const forcedAssignments = [];
            
            workersData.forEach(w => {
                assignedHours[w.email] = 0;
                wsStatus[w.email] = w.work_study || false;
                availabilityHours[w.email] = calculateAvailabilityHours(w);
            });

            const wsWorkers = workersData.filter(w => wsStatus[w.email]);
            wsWorkers.sort((a, b) => availabilityHours[a.email] - availabilityHours[b.email]);

            const wsAvailabilityIssues = checkWorkStudyAvailability(wsWorkers, hoursOfOperation);
            const initialWsIssues = wsAvailabilityIssues.map(([w, issue]) => 
                `${w.first_name} ${w.last_name}: ${issue}`
            );

            // Phase 1: Work Study Allocation (exactly 5 hours each)
            for (const w of wsWorkers) {
                const email = w.email;
                let remaining = 5.0;

                const windows = [];
                for (const [day, ops] of Object.entries(hoursOfOperation)) {
                    for (const op of ops) {
                        let opStart = timeToHour(op.start);
                        let opEnd = timeToHour(op.end);
                        if (opEnd <= opStart) opEnd += 24;

                        for (const a of w.availability[day] || []) {
                            const s = Math.max(opStart, a.start_hour);
                            const e = Math.min(opEnd, a.end_hour);
                            if (e > s) {
                                windows.push([day, s, e]);
                            }
                        }
                    }
                }

                const optimalShifts = findOptimalShiftSplit(windows, remaining, true);

                for (const [day, start, end, duration] of optimalShifts) {
                    const slotStart = hourToTime(start);
                    const slotEnd = hourToTime(end);
                    
                    const existingShifts = (schedule[day] || []).filter(s => 
                        s.start === slotStart && s.end === slotEnd
                    );
                    
                    if (existingShifts.length < maxWorkersPerShift) {
                        if (!schedule[day]) schedule[day] = [];
                        
                        schedule[day].push({
                            start: slotStart,
                            end: slotEnd,
                            assigned: [`${w.first_name} ${w.last_name}`],
                            available: [`${w.first_name} ${w.last_name}`],
                            raw_assigned: [email],
                            all_available: [w],
                            is_work_study: true
                        });
                        
                        assignedHours[email] += duration;
                        remaining -= duration;
                    }
                }
            }

            // Phase 2: Enhanced Coverage Algorithm - Fill ALL operating hours
            const orderedDays = [...DAYS].sort();
            
            for (const day of orderedDays) {
                const ops = hoursOfOperation[day] || [];
                if (ops.length === 0) continue;
                
                if (!schedule[day]) schedule[day] = [];

                for (const op of ops) {
                    let opStart = timeToHour(op.start);
                    let opEnd = timeToHour(op.end);
                    if (opEnd <= opStart) opEnd += 24;

                    // Create continuous coverage for entire operating period
                    if (ensureFullCoverage) {
                        // Calculate existing coverage
                        const existingShifts = schedule[day].map(s => ({
                            start: timeToHour(s.start),
                            end: timeToHour(s.end)
                        })).sort((a, b) => a.start - b.start);

                        // Merge overlapping shifts
                        const mergedShifts = [];
                        for (const shift of existingShifts) {
                            if (mergedShifts.length === 0 || mergedShifts[mergedShifts.length - 1].end < shift.start) {
                                mergedShifts.push(shift);
                            } else {
                                mergedShifts[mergedShifts.length - 1].end = Math.max(mergedShifts[mergedShifts.length - 1].end, shift.end);
                            }
                        }

                        // Find gaps that need to be filled
                        const gaps = [];
                        let currentTime = opStart;
                        
                        for (const shift of mergedShifts) {
                            if (shift.start > currentTime) {
                                gaps.push([currentTime, shift.start]);
                            }
                            currentTime = Math.max(currentTime, shift.end);
                        }
                        
                        if (currentTime < opEnd) {
                            gaps.push([currentTime, opEnd]);
                        }

                        // Fill each gap
                        for (const [gapStart, gapEnd] of gaps) {
                            let cur = gapStart;
                            while (cur < gapEnd) {
                                const remainingTime = gapEnd - cur;
                                const shiftLength = Math.min(Math.max(2, remainingTime), 4); // 2-4 hour shifts
                                const endShift = Math.min(cur + shiftLength, gapEnd);
                                const shiftDuration = endShift - cur;

                                // Find available workers for this gap
                                const availableWorkers = [];
                                
                                for (const x of workersData) {
                                    const xEmail = x.email;
                                    
                                    if (wsStatus[xEmail] && assignedHours[xEmail] >= 5) continue;
                                    if (wsStatus[xEmail] && assignedHours[xEmail] === 0) continue;
                                    
                                    if (isWorkerAvailable(x, day, cur, endShift) && 
                                        assignedHours[xEmail] + shiftDuration <= maxHoursPerWorker) {
                                        availableWorkers.push(x);
                                    }
                                }

                                // Sort by fairness
                                availableWorkers.sort((a, b) => {
                                    const ratioA = assignedHours[a.email] / Math.max(availabilityHours[a.email], 1);
                                    const ratioB = assignedHours[b.email] / Math.max(availabilityHours[b.email], 1);
                                    return ratioA - ratioB;
                                });

                                const chosen = availableWorkers.slice(0, maxWorkersPerShift);

                                // Assign shifts
                                for (const x of chosen) {
                                    assignedHours[x.email] += shiftDuration;
                                    schedule[day].push({
                                        start: hourToTime(cur),
                                        end: hourToTime(endShift),
                                        assigned: [`${x.first_name} ${x.last_name}`],
                                        available: availableWorkers.map(y => `${y.first_name} ${y.last_name}`),
                                        raw_assigned: [x.email],
                                        all_available: availableWorkers
                                    });
                                }

                                // Mark unfilled if we couldn't fill all positions
                                for (let i = 0; i < maxWorkersPerShift - chosen.length; i++) {
                                    unfilledShifts.push({
                                        day: day,
                                        start: hourToTime(cur),
                                        end: hourToTime(endShift),
                                        start_hour: cur,
                                        end_hour: endShift,
                                        isGap: true
                                    });
                                    
                                    schedule[day].push({
                                        start: hourToTime(cur),
                                        end: hourToTime(endShift),
                                        assigned: ["‚ö†Ô∏è COVERAGE GAP"],
                                        available: availableWorkers.map(y => `${y.first_name} ${y.last_name}`),
                                        raw_assigned: [],
                                        all_available: availableWorkers,
                                        isGap: true
                                    });
                                }

                                cur = endShift;
                            }
                        }
                    }
                }
            }

            // Validate coverage and generate reports
            const { coverageGaps } = validateScheduleCoverage(schedule, hoursOfOperation);

            // Build summaries
            const lowHours = workersData
                .filter(w => !wsStatus[w.email] && assignedHours[w.email] < 4)
                .map(w => `${w.first_name} ${w.last_name}`);
                
            const unassigned = workersData
                .filter(w => assignedHours[w.email] === 0)
                .map(w => `${w.first_name} ${w.last_name}`);

            const wsIssues = [
                ...initialWsIssues,
                ...workersData
                    .filter(w => wsStatus[w.email] && Math.abs(assignedHours[w.email] - 5) > 0.1)
                    .filter(w => !initialWsIssues.some(issue => 
                        issue.startsWith(`${w.first_name} ${w.last_name}:`)))
                    .map(w => `${w.first_name} ${w.last_name} (${assignedHours[w.email].toFixed(1)}h)`)
            ];

            const minHoursIssues = workersData
                .filter(w => !wsStatus[w.email] && assignedHours[w.email] < minHoursPerWorker && assignedHours[w.email] > 0)
                .map(w => `${w.first_name} ${w.last_name} (${assignedHours[w.email].toFixed(1)}h)`);

            // Alternative solutions
            const altSols = {};
            for (const us of unfilledShifts) {
                const key = `${us.day} ${us.start}-${us.end}`;
                const sols = workersData.filter(w => {
                    return isWorkerAvailable(w, us.day, us.start_hour, us.end_hour) &&
                           assignedHours[w.email] + (us.end_hour - us.start_hour) <= maxHoursPerWorker * 1.2;
                });
                
                if (sols.length > 0) {
                    altSols[key] = sols.map(w => `${w.first_name} ${w.last_name}`);
                }
            }

            // After normal assignment and before validation/reporting:
            // Attempt to fill every unfilled shift with the closest available worker (least hours, prioritize zero hours)
            for (const us of unfilledShifts) {
                // Find eligible workers: have availability for this shift, not double-booked, not over max hours
                const eligible = workersData.filter(w => {
                    // Must have availability for this shift
                    if (!isWorkerAvailable(w, us.day, us.start_hour, us.end_hour)) return false;
                    // Not already assigned to an overlapping or adjacent shift
                    const assignedShifts = Object.values(schedule).flat().filter(s => (s.raw_assigned||[]).includes(w.email));
                    for (const s of assignedShifts) {
                        const sDay = s.day || Object.keys(schedule).find(d => schedule[d].includes(s));
                        if (sDay !== us.day) continue;
                        const sStart = timeToHour(s.start);
                        const sEnd = timeToHour(s.end);
                        // Overlap or adjacent
                        if (!(us.end_hour <= sStart || us.start_hour >= sEnd)) return false;
                        if (Math.abs(us.start_hour - sEnd) < 0.01 || Math.abs(us.end_hour - sStart) < 0.01) return false;
                    }
                    // Not over max hours
                    if ((assignedHours[w.email] || 0) + (us.end_hour - us.start_hour) > maxHoursPerWorker) return false;
                    return true;
                });
                // Prioritize workers with zero hours, then least hours
                eligible.sort((a, b) => {
                    const aHours = assignedHours[a.email] || 0;
                    const bHours = assignedHours[b.email] || 0;
                    if (aHours === 0 && bHours > 0) return -1;
                    if (bHours === 0 && aHours > 0) return 1;
                    return aHours - bHours;
                });
                if (eligible.length > 0) {
                    const chosen = eligible[0];
                    assignedHours[chosen.email] = (assignedHours[chosen.email] || 0) + (us.end_hour - us.start_hour);
                    if (!schedule[us.day]) schedule[us.day] = [];
                    schedule[us.day].push({
                        start: us.start,
                        end: us.end,
                        assigned: [`${chosen.first_name} ${chosen.last_name}`],
                        available: eligible.map(w => `${w.first_name} ${w.last_name}`),
                        raw_assigned: [chosen.email],
                        all_available: eligible,
                        forced: true
                    });
                    forcedAssignments.push({
                        day: us.day,
                        start: us.start,
                        end: us.end,
                        worker: `${chosen.first_name} ${chosen.last_name}`,
                        email: chosen.email
                    });
                }
            }

            console.log('Enhanced schedule generation complete with coverage analysis');
            
            return {
                schedule,
                assignedHours,
                lowHours,
                unassigned,
                altSols,
                unfilledShifts,
                wsIssues,
                minHoursIssues,
                coverageGaps,
                forcedAssignments
            };
        };

        // Initialize workplaces with enhanced error handling
        async function initializeDefaultWorkplaces() {
            const workplaces = [
                { 
                    id: 'esports_lounge', 
                    name: 'üéÆ eSports Lounge',
                    hours: {
                        Monday: [{ start: "09:00", end: "17:00" }],
                        Tuesday: [{ start: "09:00", end: "17:00" }],
                        Wednesday: [{ start: "09:00", end: "17:00" }],
                        Thursday: [{ start: "09:00", end: "17:00" }],
                        Friday: [{ start: "09:00", end: "17:00" }],
                        Saturday: [{ start: "10:00", end: "16:00" }],
                        Sunday: [{ start: "12:00", end: "18:00" }]
                    }
                },
                { 
                    id: 'esports_arena', 
                    name: 'üèüÔ∏è eSports Arena',
                    hours: {
                        Monday: [{ start: "10:00", end: "20:00" }],
                        Tuesday: [{ start: "10:00", end: "20:00" }],
                        Wednesday: [{ start: "10:00", end: "20:00" }],
                        Thursday: [{ start: "10:00", end: "20:00" }],
                        Friday: [{ start: "10:00", end: "22:00" }],
                        Saturday: [{ start: "09:00", end: "22:00" }],
                        Sunday: [{ start: "11:00", end: "19:00" }]
                    }
                },
                { 
                    id: 'it_service_center', 
                    name: 'üíª IT Service Center',
                    hours: {
                        Monday: [{ start: "08:00", end: "16:00" }],
                        Tuesday: [{ start: "08:00", end: "16:00" }],
                        Wednesday: [{ start: "08:00", end: "16:00" }],
                        Thursday: [{ start: "08:00", end: "16:00" }],
                        Friday: [{ start: "08:00", end: "16:00" }],
                        Saturday: [{ start: "09:00", end: "15:00" }],
                        Sunday: [{ start: "10:00", end: "14:00" }]
                    }
                }
            ];

            for (const workplace of workplaces) {
                try {
                    const docRef = doc(db, 'workplaces', workplace.id);
                    const docSnap = await getDoc(docRef);
                    
                    if (!docSnap.exists()) {
                        await setDoc(docRef, {
                            name: workplace.name,
                            hours_of_operation: workplace.hours,
                            created_at: new Date().toISOString()
                        });
                        console.log(`Created workplace: ${workplace.id}`);
                    }
                } catch (error) {
                    console.error(`Error creating ${workplace.id}:`, error);
                }
            }
        }

        initializeDefaultWorkplaces();

        // Enhanced workplace selection
        window.selectWorkplace = async function(id) {
            selectedWorkplace = id;
            
            document.querySelectorAll('.workplace-card').forEach(card => {
                card.classList.remove('selected');
            });
            event.target.closest('.workplace-card').classList.add('selected');
            
            document.getElementById('scheduleContent').style.display = 'block';
            
            // Show loading state
            document.getElementById('scheduleDisplay').innerHTML = '<div class="loading">üîÑ Loading workplace data...</div>';
            
            try {
                await loadWorkplaceData();
                document.getElementById('scheduleDisplay').innerHTML = '<div class="loading">‚úÖ Ready! Select an option above to get started.</div>';
                hideAllForms();
            } catch (error) {
                console.error('Error loading workplace:', error);
                document.getElementById('scheduleDisplay').innerHTML = '<div class="error">‚ùå Error loading workplace data. Please try again.</div>';
            }
        };

        // Enhanced data loading with better error handling
        async function loadWorkplaceData() {
            try {
                console.log(`Loading data for ${selectedWorkplace}`);
                
                setLoading('scheduleDisplay', true);
                
                // Load workers with timeout
                const workersPromise = getDocs(collection(db, 'workplaces', selectedWorkplace, 'workers'));
                const workersSnapshot = await Promise.race([
                    workersPromise,
                    new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 10000))
                ]);
                
                workers = [];
                workersSnapshot.forEach(doc => {
                    try {
                        const data = doc.data();
                        const availability = parseAvailability(data['Days & Times Available'] || '');
                        
                        workers.push({
                            id: doc.id,
                            first_name: data['First Name'] || 'Unknown',
                            last_name: data['Last Name'] || 'Worker',
                            email: data['Email'] || 'no-email',
                            work_study: data['Work Study'] === 'Yes',
                            availability,
                            availability_text: data['Days & Times Available'] || ''
                        });
                    } catch (error) {
                        console.error('Error parsing worker data:', error);
                    }
                });

                // Load operating hours
                const workplaceDoc = await getDoc(doc(db, 'workplaces', selectedWorkplace));
                if (workplaceDoc.exists()) {
                    hours = workplaceDoc.data().hours_of_operation || {};
                } else {
                    hours = {};
                }

                console.log(`Loaded ${workers.length} workers and operating hours for ${selectedWorkplace}`);
                showNotification(`‚úÖ Loaded ${workers.length} workers for ${selectedWorkplace}`, 'success');
                
            } catch (error) {
                console.error('Error loading workplace data:', error);
                workers = [];
                hours = {};
                showNotification('‚ùå Error loading workplace data', 'error');
                throw error;
            }
        }

        // Enhanced admin functions with permission checks
        window.showManageHours = async function() {
            if (!user.isAdmin) {
                showNotification('‚ùå Admin access required', 'error');
                return;
            }

            if (!selectedWorkplace) {
                showNotification('‚ö†Ô∏è Please select a workplace first', 'warning');
                return;
            }

            await loadWorkplaceData();
            
            let html = '<div class="hours-grid">';
            
            DAYS.forEach(day => {
                const dayHours = hours[day] || [{ start: "09:00", end: "17:00" }];
                html += `
                    <div class="day-hours">
                        <h5>${day}</h5>
                        <div class="form-row">
                            <div class="form-group">
                                <label>Start Time</label>
                                <input type="time" id="start_${day}" value="${dayHours[0]?.start || '09:00'}">
                            </div>
                            <div class="form-group">
                                <label>End Time</label>
                                <input type="time" id="end_${day}" value="${dayHours[0]?.end || '17:00'}">
                            </div>
                        </div>
                    </div>
                `;
            });
            
            html += '</div>';
            html += '<button class="btn btn-success" onclick="saveHours()" id="saveHoursBtn">üíæ Save Hours</button>';
            
            document.getElementById('hoursModalContent').innerHTML = html;
            document.getElementById('hoursModal').style.display = 'block';
        };

        window.saveHours = async function() {
            if (!user.isAdmin) {
                showNotification('‚ùå Admin access required', 'error');
                return;
            }

            setLoading('saveHoursBtn', true);
            
            try {
                const newHours = {};
                let hasErrors = false;
                
                DAYS.forEach(day => {
                    const start = document.getElementById(`start_${day}`).value;
                    const end = document.getElementById(`end_${day}`).value;
                    
                    if (start && end) {
                        if (timeToHour(end) <= timeToHour(start)) {
                            showNotification(`‚ùå ${day}: End time must be after start time`, 'error');
                            hasErrors = true;
                            return;
                        }
                        newHours[day] = [{ start, end }];
                    }
                });
                
                if (hasErrors) {
                    setLoading('saveHoursBtn', false);
                    return;
                }
                
                await updateDoc(doc(db, 'workplaces', selectedWorkplace), {
                    hours_of_operation: newHours,
                    updated_at: new Date().toISOString(),
                    updated_by: user.email
                });
                
                hours = newHours;
                showNotification('‚úÖ Hours updated successfully!', 'success');
                closeModal('hoursModal');
                
            } catch (error) {
                console.error('Error saving hours:', error);
                showNotification('‚ùå Error saving hours', 'error');
            } finally {
                setLoading('saveHoursBtn', false);
            }
        };

        window.showManageWorkers = async function() {
            if (!user.isAdmin) {
                showNotification('‚ùå Admin access required', 'error');
                return;
            }

            if (!selectedWorkplace) {
                showNotification('‚ö†Ô∏è Please select a workplace first', 'warning');
                return;
            }

            document.getElementById('workersModalContent').innerHTML = '<div class="loading">Loading workers...</div>';
            document.getElementById('workersModal').style.display = 'block';
            
            await loadWorkplaceData();
            displayWorkersInModal();
        };

        function displayWorkersInModal() {
            let html = `
                <div style="margin-bottom: 1rem;">
                    <button class="btn btn-success" onclick="showAddWorker()">‚ûï Add New Worker</button>
                    <span style="margin-left: 1rem; color: #666;">Total: ${workers.length} workers</span>
                </div>
            `;
            
            if (workers.length === 0) {
                html += '<div class="warning">No workers found. Add your first worker to get started!</div>';
            } else {
                html += `
                    <table class="worker-table">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Email</th>
                                <th>Work Study</th>
                                <th>Availability</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                `;
                
                workers.forEach(worker => {
                    html += `
                        <tr>
                            <td><strong>${worker.first_name} ${worker.last_name}</strong></td>
                            <td>${worker.email}</td>
                            <td>${worker.work_study ? '‚úÖ Yes' : '‚ùå No'}</td>
                            <td><small>${worker.availability_text || 'No availability set'}</small></td>
                            <td>
                                <div class="worker-actions">
                                    <button class="btn btn-warning" onclick="editWorker('${worker.id}')">‚úèÔ∏è Edit</button>
                                    <button class="btn btn-danger" onclick="deleteWorker('${worker.id}')">üóëÔ∏è Delete</button>
                                </div>
                            </td>
                        </tr>
                    `;
                });
                
                html += '</tbody></table>';
            }
            
            document.getElementById('workersModalContent').innerHTML = html;
        }

        // Modal functions
        window.closeModal = function(modalId) {
            document.getElementById(modalId).style.display = 'none';
        };

        // Enhanced worker management with validation
        window.showAddWorker = function() {
            if (!user.isAdmin) {
                showNotification('‚ùå Admin access required', 'error');
                return;
            }

            editingWorkerId = null;
            document.getElementById('workerFormTitle').textContent = '‚ûï Add Worker';
            document.getElementById('workerForm').reset();
            closeModal('workersModal');
            document.getElementById('workerFormModal').style.display = 'block';
        };

        window.editWorker = function(workerId) {
            if (!user.isAdmin) {
                showNotification('‚ùå Admin access required', 'error');
                return;
            }

            const worker = workers.find(w => w.id === workerId);
            if (!worker) {
                showNotification('‚ùå Worker not found', 'error');
                return;
            }

            editingWorkerId = workerId;
            document.getElementById('workerFormTitle').textContent = '‚úèÔ∏è Edit Worker';
            
            document.getElementById('workerFirstName').value = worker.first_name;
            document.getElementById('workerLastName').value = worker.last_name;
            document.getElementById('workerEmail').value = worker.email;
            document.getElementById('workerWorkStudy').value = worker.work_study ? 'Yes' : 'No';
            document.getElementById('workerAvailability').value = worker.availability_text;
            
            closeModal('workersModal');
            document.getElementById('workerFormModal').style.display = 'block';
        };

        window.deleteWorker = async function(workerId) {
            if (!user.isAdmin) {
                showNotification('‚ùå Admin access required', 'error');
                return;
            }

            const worker = workers.find(w => w.id === workerId);
            if (!worker) return;

            if (!confirm(`Are you sure you want to delete ${worker.first_name} ${worker.last_name}? This cannot be undone.`)) return;

            try {
                await deleteDoc(doc(db, 'workplaces', selectedWorkplace, 'workers', workerId));
                showNotification('‚úÖ Worker deleted successfully!', 'success');
                await loadWorkplaceData();
                displayWorkersInModal();
            } catch (error) {
                console.error('Error deleting worker:', error);
                showNotification('‚ùå Error deleting worker', 'error');
            }
        };

        // Enhanced worker form validation and submission
        document.getElementById('workerForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            
            if (!user.isAdmin) {
                showNotification('‚ùå Admin access required', 'error');
                return;
            }

            const firstName = document.getElementById('workerFirstName').value.trim();
            const lastName = document.getElementById('workerLastName').value.trim();
            const email = document.getElementById('workerEmail').value.trim();
            const workStudy = document.getElementById('workerWorkStudy').value;
            const availability = document.getElementById('workerAvailability').value.trim();

            // Enhanced validation
            if (!firstName || !lastName) {
                showNotification('‚ùå First and last name are required', 'error');
                return;
            }

            if (!email || !email.includes('@')) {
                showNotification('‚ùå Valid email address is required', 'error');
                return;
            }

            // Check for duplicate email (excluding current worker if editing)
            const duplicateWorker = workers.find(w => 
                w.email.toLowerCase() === email.toLowerCase() && 
                w.id !== editingWorkerId
            );
            
            if (duplicateWorker) {
                showNotification('‚ùå A worker with this email already exists', 'error');
                return;
            }

            // Validate availability format if provided
            if (availability) {
                try {
                    const parsed = parseAvailability(availability);
                    if (Object.keys(parsed).length === 0) {
                        showNotification('‚ö†Ô∏è No valid availability detected. Please check the format: "Mon 09:00-17:00, Tue 10:00-16:00"', 'warning');
                    }
                } catch (error) {
                    showNotification('‚ùå Invalid availability format. Use: "Day HH:MM-HH:MM"', 'error');
                    return;
                }
            }

            const submitBtn = document.querySelector('#workerForm button[type="submit"]');
            setLoading(submitBtn.id || 'submitBtn', true);

            const workerData = {
                'First Name': firstName,
                'Last Name': lastName,
                'Email': email,
                'Work Study': workStudy,
                'Days & Times Available': availability,
                'updated_at': new Date().toISOString(),
                'updated_by': user.email
            };

            try {
                if (editingWorkerId) {
                    await updateDoc(doc(db, 'workplaces', selectedWorkplace, 'workers', editingWorkerId), workerData);
                    showNotification('‚úÖ Worker updated successfully!', 'success');
                } else {
                    workerData.created_at = new Date().toISOString();
                    workerData.created_by = user.email;
                    await addDoc(collection(db, 'workplaces', selectedWorkplace, 'workers'), workerData);
                    showNotification('‚úÖ Worker added successfully!', 'success');
                }
                
                closeModal('workerFormModal');
                await loadWorkplaceData();
                
            } catch (error) {
                console.error('Error saving worker:', error);
                showNotification('‚ùå Error saving worker', 'error');
            } finally {
                setLoading(submitBtn.id || 'submitBtn', false);
            }
        });

        // Form display functions
        window.showGenerateForm = function() {
            if (!user.isAdmin) {
                showNotification('‚ùå Admin access required', 'error');
                return;
            }
            hideAllForms();
            document.getElementById('generateForm').style.display = 'block';
        };

        window.checkAvailability = function() {
            hideAllForms();
            document.getElementById('availabilityForm').style.display = 'block';
        };

        window.hideAllForms = function() {
            document.querySelectorAll('.form-section').forEach(form => {
                form.style.display = 'none';
            });
        };

        // Enhanced worker viewing
        window.viewWorkers = function() {
            if (workers.length === 0) {
                let html = `
                    <div class="schedule-display">
                        <h3>üë• Workers for ${selectedWorkplace}</h3>
                        <div class="warning">
                            <strong>No workers found for this workplace.</strong><br>
                            Workers are required to generate schedules and check availability.
                        </div>
                `;
                
                if (user.isAdmin) {
                    html += '<button class="btn btn-success" onclick="showAddWorker()">‚ûï Add First Worker</button>';
                } else {
                    html += '<div class="info">Contact an administrator to add workers.</div>';
                }
                
                html += '</div>';
                document.getElementById('scheduleDisplay').innerHTML = html;
                return;
            }

            const wsCount = workers.filter(w => w.work_study).length;
            const regularCount = workers.filter(w => !w.work_study).length;
            const workersWithAvailability = workers.filter(w => w.availability_text).length;

            let html = `
                <div class="schedule-display">
                    <h3>üë• Workers for ${selectedWorkplace}</h3>
                    <div class="stats">
                        <div class="stat-card">
                            <div class="stat-number">${workers.length}</div>
                            <div class="stat-label">Total Workers</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-number">${wsCount}</div>
                            <div class="stat-label">Work Study</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-number">${regularCount}</div>
                            <div class="stat-label">Regular Workers</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-number">${workersWithAvailability}</div>
                            <div class="stat-label">With Availability</div>
                        </div>
                    </div>
            `;

            // Show warning if workers don't have availability
            if (workersWithAvailability < workers.length) {
                const missingCount = workers.length - workersWithAvailability;
                html += `
                    <div class="warning">
                        <strong>‚ö†Ô∏è ${missingCount} worker(s) don't have availability set.</strong><br>
                        Workers without availability cannot be scheduled. ${user.isAdmin ? 'Edit workers to add their availability.' : 'Contact an administrator to update worker availability.'}
                    </div>
                `;
            }

            html += `
                <table class="worker-table">
                    <thead>
                        <tr>
                            <th>Name</th>
                            <th>Email</th>
                            <th>Work Study</th>
                            <th>Availability Status</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            workers.forEach(worker => {
                const availabilityStatus = worker.availability_text ? 
                    '‚úÖ Set' : 
                    '<span style="color: #dc3545;">‚ùå Missing</span>';
                    
                html += `
                    <tr>
                        <td><strong>${worker.first_name} ${worker.last_name}</strong></td>
                        <td>${worker.email}</td>
                        <td>${worker.work_study ? '<span style="color: #28a745;">‚úÖ Yes</span>' : '‚ùå No'}</td>
                        <td>${availabilityStatus}</td>
                        <td>
                            <button class="btn btn-primary" onclick="contactWorker('${worker.email}')">üìß Contact</button>
                            ${user.isAdmin ? `<button class="btn btn-warning" onclick="editWorker('${worker.id}')" style="margin-left: 0.5rem;">‚úèÔ∏è Edit</button>` : ''}
                        </td>
                    </tr>
                `;
            });

            html += '</tbody></table>';
            
            // Admin action buttons
            if (user.isAdmin) {
                html += `
                    <div style="margin-top: 1.5rem; display: flex; gap: 1rem; flex-wrap: wrap;">
                        <button class="btn btn-success" onclick="showAddWorker()">‚ûï Add Worker</button>
                        <button class="btn btn-warning" onclick="showLastMinuteCheck()">üö® Last Minute Check</button>
                        <button class="btn btn-info" onclick="showManageWorkers()">üë• Manage Workers</button>
                    </div>
                `;
            }
            
            html += '</div>';
            document.getElementById('scheduleDisplay').innerHTML = html;
            hideAllForms();
        };

        // Enhanced schedule generation with comprehensive validation
        window.generateSchedule = async function() {
            if (!user.isAdmin) {
                showNotification('‚ùå Admin access required', 'error');
                return;
            }

            if (!selectedWorkplace) {
                showNotification('‚ö†Ô∏è Please select a workplace first', 'warning');
                return;
            }

            if (workers.length === 0) {
                showNotification('‚ùå No workers found. Add workers before generating a schedule.', 'error');
                return;
            }

            if (Object.keys(hours).length === 0) {
                showNotification('‚ùå No operating hours configured. Set up hours of operation first.', 'error');
                return;
            }

            // Validate worker availability
            const workersWithAvailability = workers.filter(w => w.availability_text && Object.keys(w.availability).length > 0);
            if (workersWithAvailability.length === 0) {
                showNotification('‚ùå No workers have availability set. Add worker availability before generating schedules.', 'error');
                return;
            }

            const maxHours = parseInt(document.getElementById('maxHours').value);
            const workersPerShift = parseInt(document.getElementById('workersPerShift').value);
            const minHours = parseInt(document.getElementById('minHours').value);
            const variation = document.getElementById('scheduleVariation').value;
            const ensureFullCoverage = document.getElementById('ensureFullCoverage').checked;
            
            // Validation
            if (maxHours < 5 || maxHours > 40) {
                showNotification('‚ùå Max hours must be between 5 and 40', 'error');
                return;
            }

            if (workersPerShift < 1 || workersPerShift > 5) {
                showNotification('‚ùå Workers per shift must be between 1 and 5', 'error');
                return;
            }

            setLoading('generateScheduleBtn', true);
            document.getElementById('scheduleDisplay').innerHTML = '<div class="loading">üîÑ Generating optimized schedule...</div>';
            
            try {
                // Apply variation-specific processing
                let processedWorkers = [...workersWithAvailability];
                
                switch (variation) {
                    case 'random':
                        processedWorkers = shuffleArray(processedWorkers);
                        break;
                    case 'work_study_first':
                        processedWorkers.sort((a, b) => {
                            if (a.work_study && !b.work_study) return -1;
                            if (!a.work_study && b.work_study) return 1;
                            return 0;
                        });
                        break;
                    case 'fair_rotation':
                        processedWorkers.sort((a, b) => {
                            return calculateAvailabilityHours(a) - calculateAvailabilityHours(b);
                        });
                        break;
                    default: // balanced
                        processedWorkers.sort((a, b) => {
                            if (a.work_study && !b.work_study) return -1;
                            if (!a.work_study && b.work_study) return 1;
                            return calculateAvailabilityHours(a) - calculateAvailabilityHours(b);
                        });
                }
                
                // Generate schedule
                const result = createShiftsFromAvailability(
                    hours, 
                    processedWorkers,
                    maxHours,
                    workersPerShift,
                    minHours,
                    ensureFullCoverage
                );
                
                const {
                    schedule: generatedSchedule,
                    assignedHours,
                    lowHours,
                    unassigned,
                    altSols,
                    unfilledShifts,
                    wsIssues,
                    minHoursIssues,
                    coverageGaps,
                    forcedAssignments
                } = result;

                // Update global schedule
                schedule = generatedSchedule;

                // Save to Firebase
                await saveSchedule(schedule, variation, {
                    maxHours,
                    workersPerShift,
                    minHours,
                    ensureFullCoverage,
                    workersCount: processedWorkers.length
                });
                
                // Show comprehensive issues dialog if needed
                if (unfilledShifts.length > 0 || wsIssues.length > 0 || minHoursIssues.length > 0 || coverageGaps.length > 0) {
                    showEnhancedIssuesDialog({
                        unfilledShifts,
                        wsIssues,
                        minHoursIssues,
                        coverageGaps,
                        altSols,
                        forcedAssignments
                    });
                }

                // Display the generated schedule
                displayEnhancedSchedule(schedule, assignedHours, lowHours, unassigned, false, coverageGaps);
                hideAllForms();
                
                showNotification('‚úÖ Schedule generated successfully!', 'success');
                
            } catch (error) {
                console.error('Error generating schedule:', error);
                document.getElementById('scheduleDisplay').innerHTML = `<div class="error">‚ùå Error generating schedule: ${error.message}</div>`;
                showNotification('‚ùå Failed to generate schedule', 'error');
            } finally {
                setLoading('generateScheduleBtn', false);
            }
        };

        // Enhanced schedule saving with metadata
        async function saveSchedule(schedule, variation, metadata = {}) {
            try {
                const scheduleData = {
                    days: schedule,
                    createdAt: new Date().toISOString(),
                    workplaceId: selectedWorkplace,
                    name: `${selectedWorkplace} Schedule ${new Date().toLocaleDateString()}`,
                    variation: variation,
                    generatedBy: user.email,
                    metadata: {
                        ...metadata,
                        version: '2.0',
                        totalShifts: Object.values(schedule).flat().length,
                        workersUsed: Object.values(schedule).flat()
                            .map(s => s.raw_assigned || [])
                            .flat()
                            .filter((email, index, arr) => arr.indexOf(email) === index).length
                    }
                };
                
                await addDoc(collection(db, 'workplaces', selectedWorkplace, 'schedules'), scheduleData);
                console.log('Enhanced schedule saved to Firebase');
            } catch (error) {
                console.error('Error saving schedule:', error);
                throw error;
            }
        }

        // Enhanced issues dialog with coverage gaps
        function showEnhancedIssuesDialog(issues) {
            const { unfilledShifts, wsIssues, minHoursIssues, coverageGaps, altSols, forcedAssignments } = issues;
            
            let html = '<div class="modal-content"><div class="modal-header"><h3>‚ö†Ô∏è Schedule Analysis & Issues</h3><span class="close" onclick="closeIssuesDialog()">&times;</span></div>';
            
            // Coverage gaps (critical)
            if (coverageGaps && coverageGaps.length > 0) {
                html += '<div class="error"><h4>üö® Critical Coverage Gaps:</h4><ul>';
                coverageGaps.forEach(gap => {
                    html += `<li><strong>${gap.day}</strong> ${formatTime(gap.start)} - ${formatTime(gap.end)} (${gap.duration.toFixed(1)} hours uncovered)</li>`;
                });
                html += '</ul><p><strong>Action needed:</strong> These time periods have no worker coverage during operating hours.</p></div>';
            }
            
            // Forced assignments section
            if (forcedAssignments && forcedAssignments.length > 0) {
                html += '<div class="error"><h4>‚ùó Forced Assignments (Closest Worker Assigned):</h4><ul>';
                forcedAssignments.forEach(fa => {
                    html += `<li><strong>${fa.day}</strong> ${formatTime(fa.start)} - ${formatTime(fa.end)}: ${fa.worker} <span style=\"color:#e53935;font-weight:bold;\">(FORCED)</span></li>`;
                });
                html += '</ul><p><strong>Warning:</strong> These shifts were filled by assigning the closest available worker (least hours, prioritized for fairness). Please review these assignments as they may not match worker preferences or may be less ideal.</p></div>';
            }
            
            // Work study issues
            if (wsIssues.length > 0) {
                html += '<div class="warning"><h4>üéì Work Study Issues:</h4><ul>';
                wsIssues.forEach(issue => {
                    html += `<li>${issue}</li>`;
                });
                html += '</ul><p><strong>Note:</strong> Work study students must have exactly 5 hours per week.</p></div>';
            }
            
            // Low hours issues
            if (minHoursIssues.length > 0) {
                html += '<div class="warning"><h4>‚è∞ Workers with Insufficient Hours:</h4><ul>';
                minHoursIssues.forEach(issue => {
                    html += `<li>${issue}</li>`;
                });
                html += '</ul></div>';
            }
            
            // Unfilled shifts
            if (unfilledShifts.length > 0) {
                html += '<div class="error"><h4>‚ùå Unfilled Shifts:</h4><ul>';
                unfilledShifts.forEach(shift => {
                    const key = `${shift.day} ${shift.start}-${shift.end}`;
                    html += `<li><strong>${key}</strong>`;
                    if (altSols[key] && altSols[key].length > 0) {
                        html += ` - <em>Potential alternatives:</em> ${altSols[key].join(', ')}`;
                    } else {
                        html += ' - <em>No available alternatives found</em>';
                    }
                    html += '</li>';
                });
                html += '</ul></div>';
            }
            
            // Success message if no major issues
            if (!coverageGaps?.length && !unfilledShifts.length && !wsIssues.length) {
                html += '<div class="success"><h4>‚úÖ Schedule Quality: Excellent</h4><p>No critical issues found. The schedule provides complete coverage with proper work study allocation.</p></div>';
            }
            
            html += '<div style="margin-top: 1rem;"><button class="btn btn-secondary" onclick="closeIssuesDialog()">Close Analysis</button></div></div>';
            
            // Create and show modal
            const modal = document.createElement('div');
            modal.id = 'issuesModal';
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = html;
            document.body.appendChild(modal);
            
            window.closeIssuesDialog = function() {
                document.body.removeChild(modal);
                delete window.closeIssuesDialog;
            };
        }

        // Enhanced schedule display with coverage analysis
        function displayEnhancedSchedule(schedule, assignedHours, lowHours, unassigned, isCurrent = false, coverageGaps = []) {
            const totalShifts = Object.values(schedule).flat().length;
            const unfilledShifts = Object.values(schedule).flat().filter(s => s.assigned.includes('Unfilled') || s.assigned.includes('COVERAGE GAP')).length;
            const filledShifts = totalShifts - unfilledShifts;
            const coveragePercentage = totalShifts > 0 ? ((filledShifts / totalShifts) * 100).toFixed(1) : 0;
            
            let html = '<div class="schedule-display">';
            
            // Print header for print view
            html += '<div class="print-only"><h2>üìÖ Schedule for ' + selectedWorkplace.replace('_', ' ').toUpperCase() + '</h2><p>Generated: ' + new Date().toLocaleDateString() + '</p></div>';
            
            if (isCurrent) {
                html += '<div class="success">‚úÖ This is the current active schedule</div>';
            }
            
            // Enhanced stats
            html += `
                <div class="stats">
                    <div class="stat-card">
                        <div class="stat-number">${totalShifts}</div>
                        <div class="stat-label">Total Shifts</div>
                    </div>
                    <div class="stat-card" style="background: ${coveragePercentage >= 90 ? '#28a745' : coveragePercentage >= 75 ? '#ffc107' : '#dc3545'};">
                        <div class="stat-number">${coveragePercentage}%</div>
                        <div class="stat-label">Coverage</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number">${Object.keys(assignedHours).length}</div>
                        <div class="stat-label">Workers Assigned</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number">${coverageGaps.length}</div>
                        <div class="stat-label">Coverage Gaps</div>
                    </div>
                </div>
            `;
            
            // Show critical warnings
            if (coverageGaps.length > 0) {
                html += `<div class="error"><strong>üö® ${coverageGaps.length} Critical Coverage Gap(s) Found!</strong><br>Some operating hours have no worker assigned. Check the schedule analysis for details.</div>`;
            }
            
            if (lowHours.length > 0) {
                html += `<div class="warning"><strong>Workers with less than minimum hours:</strong> ${lowHours.join(', ')}</div>`;
            }
            if (unassigned.length > 0) {
                html += `<div class="error"><strong>Workers with no hours:</strong> ${unassigned.join(', ')}</div>`;
            }
            
            // Display schedule by day with enhanced shift marking
            DAYS.forEach(day => {
                const shifts = schedule[day] || [];
                if (shifts.length === 0) return;
                
                html += `<div class="day-header">${day}</div>`;
                shifts.forEach((shift, index) => {
                    const unfilled = shift.assigned.includes('Unfilled');
                    const isGap = shift.assigned.includes('COVERAGE GAP') || shift.isGap;
                    const workStudy = shift.is_work_study || false;
                    const isForced = shift.forced === true;
                    
                    let shiftClass = 'shift';
                    if (isGap) shiftClass += ' coverage-gap';
                    else if (unfilled) shiftClass += ' unfilled';
                    else if (workStudy) shiftClass += ' work-study';
                    if (isForced) shiftClass += ' forced-shift';
                    
                    html += `
                        <div class="${shiftClass}">
                            <div>
                                <strong>${formatTime(shift.start)} - ${formatTime(shift.end)}</strong>
                                ${workStudy ? '<span style="color: #ffc107; margin-left: 0.5rem;">(Work Study)</span>' : ''}
                                ${isGap ? '<span style="color: #ff5722; margin-left: 0.5rem;">(CRITICAL GAP)</span>' : ''}
                                ${isForced ? '<span style="color: #e53935; margin-left: 0.5rem; font-weight: bold;">(FORCED)</span>' : ''}
                                <div style="margin-top: 0.25rem; font-size: 0.9rem;">
                                    ${shift.assigned.join(', ')}
                                </div>
                            </div>
                            ${user.isAdmin ? `
                            <div class="shift-actions no-print">
                                <button class="btn btn-warning" onclick="editShift('${day}', ${index})">‚úèÔ∏è Edit</button>
                                ${(unfilled || isGap) ? '<button class="btn btn-info" onclick="suggestAlternatives(\'' + day + '\', ' + index + ')">üí° Fix</button>' : ''}
                            </div>
                            ` : ''}
                        </div>
                    `;
                });
            });
            
            // Enhanced worker hours summary
            html += '<div style="margin-top: 2rem;"><h4>üìä Worker Hours Summary</h4>';
            html += '<table class="worker-table"><thead><tr><th>Worker</th><th>Hours Assigned</th><th>Status</th><th class="no-print">Actions</th></tr></thead><tbody>';
            
            const sortedWorkers = Object.entries(assignedHours).sort((a, b) => b[1] - a[1]);
            
            workers.forEach(w => {
                if (!(w.email in assignedHours)) {
                    sortedWorkers.push([w.email, 0]);
                }
            });
            
            sortedWorkers.forEach(([email, hours]) => {
                const worker = workers.find(w => w.email === email);
                if (!worker) return;
                
                const name = `${worker.first_name} ${worker.last_name}`;
                const isWS = worker.work_study;
                let status = '‚úÖ Good';
                let statusColor = 'color: #28a745;';
                
                if (isWS && Math.abs(hours - 5) > 0.1) {
                    status = `‚ùå WS Issue (${hours.toFixed(1)}h/5h)`;
                    statusColor = 'color: #dc3545;';
                } else if (!isWS && hours < 3 && hours > 0) {
                    status = '‚ö†Ô∏è Low Hours';
                    statusColor = 'color: #ffc107;';
                } else if (hours === 0) {
                    status = '‚ùå Unassigned';
                    statusColor = 'color: #dc3545;';
                } else if (isWS && hours === 5) {
                    status = '‚úÖ Perfect (WS)';
                    statusColor = 'color: #28a745;';
                }
                
                html += `
                    <tr>
                        <td><strong>${name}</strong> ${isWS ? '<small style="color: #ffc107;">(WS)</small>' : ''}</td>
                        <td>${hours.toFixed(1)} hours</td>
                        <td style="${statusColor}">${status}</td>
                        <td class="no-print"><button class="btn btn-primary" onclick="contactWorker('${email}')">üìß Contact</button></td>
                    </tr>
                `;
            });
            
            html += '</tbody></table></div>';
            
            // Action buttons (admin vs user)
            if (user.isAdmin) {
                html += `
                    <div class="no-print" style="margin-top: 2rem; display: flex; gap: 1rem; flex-wrap: wrap;">
                        <button class="btn btn-success" onclick="addNewShift()">‚ûï Add Shift</button>
                        <button class="btn btn-info" onclick="emailSchedule()">üìß Email Schedule</button>
                        <button class="btn btn-secondary" onclick="printSchedule()">üñ®Ô∏è Print Schedule</button>
                        <button class="btn btn-warning" onclick="exportScheduleToExcel()">üì§ Export Excel</button>
                        <button class="btn btn-info" onclick="analyzeSchedule()">üìä Detailed Analysis</button>
                    </div>
                `;
            } else {
                html += `
                    <div class="no-print" style="margin-top: 2rem; display: flex; gap: 1rem; flex-wrap: wrap;">
                        <button class="btn btn-secondary" onclick="printSchedule()">üñ®Ô∏è Print Schedule</button>
                        <button class="btn btn-info" onclick="emailSchedule()">üìß Email Schedule</button>
                    </div>
                `;
            }
            
            html += '</div>';
            document.getElementById('scheduleDisplay').innerHTML = html;
        }

        // Enhanced utility functions - Email, Export, Print, Analysis
        window.emailSchedule = function() {
            const scheduleElement = document.querySelector('.schedule-display');
            if (!scheduleElement) {
                showNotification('‚ùå No schedule to email', 'error');
                return;
            }

            // Generate email content
            let emailBody = `Schedule for ${selectedWorkplace.replace('_', ' ').toUpperCase()}\n`;
            emailBody += `Generated: ${new Date().toLocaleDateString()}\n`;
            emailBody += `Generated by: ${user.email}\n\n`;
            
            // Add schedule by day
            DAYS.forEach(day => {
                const shifts = schedule[day] || [];
                if (shifts.length === 0) return;
                
                emailBody += `${day}:\n`;
                shifts.forEach(shift => {
                    const timeRange = `${formatTime(shift.start)} - ${formatTime(shift.end)}`;
                    const workers = shift.assigned.join(', ');
                    emailBody += `  ${timeRange}: ${workers}\n`;
                });
                emailBody += '\n';
            });
            
            // Add worker summary
            emailBody += 'Worker Hours Summary:\n';
            const assignedHours = calculateAssignedHours(schedule);
            Object.entries(assignedHours).forEach(([email, hours]) => {
                const worker = workers.find(w => w.email === email);
                if (worker) {
                    emailBody += `  ${worker.first_name} ${worker.last_name}: ${hours.toFixed(1)} hours\n`;
                }
            });

            const subject = `Work Schedule - ${selectedWorkplace.replace('_', ' ')} - ${new Date().toLocaleDateString()}`;
            const mailtoLink = `mailto:?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(emailBody)}`;
            
            window.open(mailtoLink);
            showNotification('üìß Email client opened with schedule', 'success');
        };

        window.exportScheduleToExcel = function() {
            if (!schedule || Object.keys(schedule).length === 0) {
                showNotification('‚ùå No schedule to export', 'error');
                return;
            }

            // Create CSV content
            let csvContent = 'Day,Start Time,End Time,Worker(s),Work Study,Duration\n';
            
            DAYS.forEach(day => {
                const shifts = schedule[day] || [];
                shifts.forEach(shift => {
                    const startTime = formatTime(shift.start);
                    const endTime = formatTime(shift.end);
                    const workers = shift.assigned.join(' & ');
                    const isWorkStudy = shift.is_work_study ? 'Yes' : 'No';
                    const duration = (timeToHour(shift.end) - timeToHour(shift.start)).toFixed(1);
                    
                    csvContent += `"${day}","${startTime}","${endTime}","${workers}","${isWorkStudy}","${duration}"\n`;
                });
            });
            
            // Create and download file
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', `${selectedWorkplace}_schedule_${new Date().toISOString().split('T')[0]}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            showNotification('üìÑ Schedule exported to CSV file', 'success');
        };

        window.printSchedule = function() {
            // Add print-specific styles
            const printStyle = document.createElement('style');
            printStyle.textContent = `
                @media print {
                    body * { visibility: hidden; }
                    .schedule-display, .schedule-display * { visibility: visible; }
                    .schedule-display { position: absolute; left: 0; top: 0; width: 100%; }
                    .no-print { display: none !important; }
                    .print-only { display: block !important; }
                }
            `;
            document.head.appendChild(printStyle);
            
            window.print();
            
            // Remove print styles after printing
            setTimeout(() => {
                document.head.removeChild(printStyle);
            }, 1000);
        };

        window.analyzeSchedule = function() {
            if (!schedule || Object.keys(schedule).length === 0) {
                showNotification('‚ùå No schedule to analyze', 'error');
                return;
            }

            const assignedHours = calculateAssignedHours(schedule);
            const totalShifts = Object.values(schedule).flat().length;
            const unfilledCount = Object.values(schedule).flat().filter(s => 
                s.assigned.includes('Unfilled') || s.assigned.includes('COVERAGE GAP')
            ).length;
            
            // Calculate metrics
            const coverage = ((totalShifts - unfilledCount) / totalShifts * 100).toFixed(1);
            const avgHoursPerWorker = Object.values(assignedHours).length > 0 ? 
                (Object.values(assignedHours).reduce((a, b) => a + b, 0) / Object.values(assignedHours).length).toFixed(1) : 0;
            
            const wsWorkers = workers.filter(w => w.work_study);
            const wsWithCorrectHours = wsWorkers.filter(w => Math.abs(assignedHours[w.email] - 5) < 0.1).length;
            const wsCompliance = wsWorkers.length > 0 ? (wsWithCorrectHours / wsWorkers.length * 100).toFixed(1) : 100;

            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-header">
                        <h3>üìä Schedule Analysis</h3>
                        <span class="close" onclick="this.closest('.modal').remove()">&times;</span>
                    </div>
                    <div style="padding: 1rem;">
                        <h4>Coverage Metrics</h4>
                        <div class="stats" style="margin-bottom: 1.5rem;">
                            <div class="stat-card">
                                <div class="stat-number">${coverage}%</div>
                                <div class="stat-label">Coverage Rate</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-number">${avgHoursPerWorker}</div>
                                <div class="stat-label">Avg Hours/Worker</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-number">${wsCompliance}%</div>
                                <div class="stat-label">WS Compliance</div>
                            </div>
                        </div>
                        
                        <h4>Recommendations</h4>
                        <ul style="margin: 1rem 0;">
                            ${coverage < 90 ? '<li>üî¥ <strong>Critical:</strong> Schedule has low coverage. Consider adjusting hours or recruiting more workers.</li>' : ''}
                            ${wsCompliance < 100 ? '<li>üü° <strong>Work Study:</strong> Some work study students don\'t have exactly 5 hours.</li>' : ''}
                            ${unfilledCount > 0 ? '<li>üî¥ <strong>Unfilled Shifts:</strong> ' + unfilledCount + ' shifts need workers assigned.</li>' : ''}
                            ${coverage >= 90 && wsCompliance == 100 && unfilledCount == 0 ? '<li>üü¢ <strong>Excellent:</strong> Schedule meets all requirements!</li>' : ''}
                        </ul>
                        
                        <button class="btn btn-secondary" onclick="this.closest('.modal').remove()">Close</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        };

        // Enhanced current schedule viewing
        window.viewCurrentSchedule = async function() {
            try {
                document.getElementById('scheduleDisplay').innerHTML = '<div class="loading">Loading current schedule...</div>';
                
                const snapshot = await getDocs(query(
                    collection(db, 'workplaces', selectedWorkplace, 'schedules'),
                    orderBy('createdAt', 'desc')
                ));
                
                if (!snapshot.empty) {
                    const doc = snapshot.docs[0];
                    const scheduleData = doc.data();
                    schedule = scheduleData.days;
                    
                    const assignedHours = calculateAssignedHours(schedule);
                    const lowHours = workers
                        .filter(w => !w.work_study && assignedHours[w.email] < 4)
                        .map(w => `${w.first_name} ${w.last_name}`);
                    const unassigned = workers
                        .filter(w => assignedHours[w.email] === 0)
                        .map(w => `${w.first_name} ${w.last_name}`);
                    
                    const { coverageGaps } = validateScheduleCoverage(schedule, hours);
                    displayEnhancedSchedule(schedule, assignedHours, lowHours, unassigned, true, coverageGaps);
                } else {
                    document.getElementById('scheduleDisplay').innerHTML = `
                        <div class="schedule-display">
                            <div class="warning">
                                <h3>üìÖ No Current Schedule Found</h3>
                                <p>No schedules have been generated for this workplace yet.</p>
                                ${user.isAdmin ? '<button class="btn btn-primary" onclick="showGenerateForm()">üìÖ Generate First Schedule</button>' : '<p>Contact an administrator to generate a schedule.</p>'}
                            </div>
                        </div>
                    `;
                }
            } catch (error) {
                console.error('Error loading current schedule:', error);
                document.getElementById('scheduleDisplay').innerHTML = '<div class="error">‚ùå Error loading schedule. Please try again.</div>';
            }
        };

        // Calculate assigned hours helper
        function calculateAssignedHours(schedule) {
            const assignedHours = {};
            
            Object.values(schedule).forEach(shifts => {
                shifts.forEach(shift => {
                    const duration = timeToHour(shift.end) - timeToHour(shift.start);
                    (shift.raw_assigned || []).forEach(email => {
                        assignedHours[email] = (assignedHours[email] || 0) + duration;
                    });
                });
            });
            
            return assignedHours;
        }

        // Enhanced history viewing
        window.viewHistory = async function() {
            try {
                document.getElementById('scheduleDisplay').innerHTML = '<div class="loading">Loading schedule history...</div>';
                
                const snapshot = await getDocs(query(
                    collection(db, 'workplaces', selectedWorkplace, 'schedules'),
                    orderBy('createdAt', 'desc')
                ));
                
                let html = '<div class="schedule-display"><h3>üìö Schedule History</h3>';
                
                if (snapshot.empty) {
                    html += `
                        <div class="info">
                            <h4>No Schedules Found</h4>
                            <p>No schedules have been generated for this workplace yet.</p>
                            ${user.isAdmin ? '<button class="btn btn-primary" onclick="showGenerateForm()">üìÖ Generate First Schedule</button>' : ''}
                        </div>
                    `;
                } else {
                    html += `<div class="info">Found ${snapshot.size} schedule(s)</div>`;
                    
                    snapshot.forEach((doc, index) => {
                        const data = doc.data();
                        const date = new Date(data.createdAt).toLocaleDateString();
                        const time = new Date(data.createdAt).toLocaleTimeString();
                        const totalShifts = data.metadata?.totalShifts || 'Unknown';
                        const workersUsed = data.metadata?.workersUsed || 'Unknown';
                        
                        const actionButtons = user.isAdmin ? `
                            <button class="btn btn-secondary" onclick="viewScheduleById('${doc.id}')">üëÅÔ∏è View</button>
                            <button class="btn btn-danger" onclick="deleteSchedule('${doc.id}')">üóëÔ∏è Delete</button>
                        ` : `
                            <button class="btn btn-secondary" onclick="viewScheduleById('${doc.id}')">üëÅÔ∏è View</button>
                        `;
                        
                        html += `
                            <div style="padding: 1rem; border: 1px solid #dee2e6; margin-bottom: 0.5rem; border-radius: 8px; display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <strong>${data.name || 'Schedule'}</strong>
                                    ${index === 0 ? '<span style="color: #28a745; font-weight: bold;"> (Current)</span>' : ''}<br>
                                    <small>üìÖ ${date} at ${time} | üë§ ${data.generatedBy || 'Unknown'}</small><br>
                                    <small>üìä ${totalShifts} shifts | üë• ${workersUsed} workers | üîÑ ${data.variation || 'balanced'}</small>
                                </div>
                                <div style="display: flex; gap: 0.5rem;">
                                    ${actionButtons}
                                </div>
                            </div>
                        `;
                    });
                }
                
                html += '</div>';
                document.getElementById('scheduleDisplay').innerHTML = html;
            } catch (error) {
                console.error('Error loading history:', error);
                document.getElementById('scheduleDisplay').innerHTML = '<div class="error">‚ùå Error loading schedule history.</div>';
            }
        };

        // View schedule by ID
        window.viewScheduleById = async function(scheduleId) {
            try {
                const docSnap = await getDoc(doc(db, 'workplaces', selectedWorkplace, 'schedules', scheduleId));
                if (docSnap.exists()) {
                    const scheduleData = docSnap.data();
                    schedule = scheduleData.days;
                    
                    const assignedHours = calculateAssignedHours(schedule);
                    const lowHours = workers
                        .filter(w => !w.work_study && assignedHours[w.email] < 4)
                        .map(w => `${w.first_name} ${w.last_name}`);
                    const unassigned = workers
                        .filter(w => assignedHours[w.email] === 0)
                        .map(w => `${w.first_name} ${w.last_name}`);
                    
                    const { coverageGaps } = validateScheduleCoverage(schedule, hours);
                    displayEnhancedSchedule(schedule, assignedHours, lowHours, unassigned, false, coverageGaps);
                }
            } catch (error) {
                console.error('Error viewing schedule:', error);
                showNotification('‚ùå Error loading schedule', 'error');
            }
        };

        // Delete schedule (admin only)
        window.deleteSchedule = async function(scheduleId) {
            if (!user.isAdmin) {
                showNotification('‚ùå Admin access required', 'error');
                return;
            }
            
            if (confirm('Delete this schedule? This cannot be undone.')) {
                try {
                    await deleteDoc(doc(db, 'workplaces', selectedWorkplace, 'schedules', scheduleId));
                    showNotification('‚úÖ Schedule deleted', 'success');
                    viewHistory();
                } catch (error) {
                    console.error('Error deleting schedule:', error);
                    showNotification('‚ùå Error deleting schedule', 'error');
                }
            }
        };

        // Enhanced availability checking
        window.findAvailable = function() {
            const day = document.getElementById('availDay').value;
            const start = document.getElementById('availStart').value;
            const end = document.getElementById('availEnd').value;
            
            if (!start || !end) {
                showNotification('‚ö†Ô∏è Please enter both start and end times', 'warning');
                return;
            }
            
            const startHour = timeToHour(start);
            const endHour = timeToHour(end);
            
            if (endHour <= startHour) {
                showNotification('‚ùå End time must be after start time', 'error');
                return;
            }
            
            const available = workers.filter(worker => {
                return isWorkerAvailable(worker, day, startHour, endHour);
            });
            
            const workStudy = available.filter(w => w.work_study);
            const regular = available.filter(w => !w.work_study);
            
            let html = `
                <div class="schedule-display">
                    <h3>üîç Available Workers</h3>
                    <div class="info">
                        <strong>Search Criteria:</strong> ${day} ${formatTime(start)} - ${formatTime(end)}<br>
                        <strong>Duration:</strong> ${(endHour - startHour).toFixed(1)} hours
                    </div>
                    <div class="stats">
                        <div class="stat-card">
                            <div class="stat-number">${available.length}</div>
                            <div class="stat-label">Total Available</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-number">${workStudy.length}</div>
                            <div class="stat-label">Work Study</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-number">${regular.length}</div>
                            <div class="stat-label">Regular Workers</div>
                        </div>
                    </div>
            `;
            
            if (available.length === 0) {
                html += '<div class="warning">‚ùå No workers are available during this time period.</div>';
            } else {
                if (workStudy.length > 0) {
                    html += '<h4>üéì Available Work Study Students</h4>';
                    workStudy.forEach(worker => {
                        html += `
                            <div style="padding: 0.75rem; border: 1px solid #28a745; margin-bottom: 0.5rem; border-radius: 8px; display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <strong>${worker.first_name} ${worker.last_name}</strong><br>
                                    <small>üìß ${worker.email}</small>
                                </div>
                                <button class="btn btn-success" onclick="contactWorker('${worker.email}')">üìß Contact</button>
                            </div>
                        `;
                    });
                }
                
                if (regular.length > 0) {
                    html += '<h4>üë• Available Regular Workers</h4>';
                    regular.forEach(worker => {
                        html += `
                            <div style="padding: 0.75rem; border: 1px solid #007bff; margin-bottom: 0.5rem; border-radius: 8px; display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <strong>${worker.first_name} ${worker.last_name}</strong><br>
                                    <small>üìß ${worker.email}</small>
                                </div>
                                <button class="btn btn-primary" onclick="contactWorker('${worker.email}')">üìß Contact</button>
                            </div>
                        `;
                    });
                }
            }
            
            html += '</div>';
            document.getElementById('scheduleDisplay').innerHTML = html;
            hideAllForms();
        };

        // Enhanced contact worker function
        window.contactWorker = function(email) {
            const subject = `Work Schedule - ${selectedWorkplace.replace('_', ' ')}`;
            const body = `Hello!\n\nI'm reaching out regarding the work schedule for ${selectedWorkplace.replace('_', ' ')}.\n\nBest regards,\n${user.email}`;
            window.open(`mailto:${email}?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`);
        };

        // Placeholder implementations for remaining features
        window.showLastMinuteCheck = function() {
            if (!user.isAdmin) {
                showNotification('‚ùå Admin access required', 'error');
                return;
            }
            showNotification('üö® Last minute check feature - Enhanced implementation coming soon!', 'info');
        };

        window.addNewShift = function() {
            if (!user.isAdmin) {
                showNotification('‚ùå Admin access required', 'error');
                return;
            }
            showNotification('‚ûï Add new shift feature - Enhanced implementation coming soon!', 'info');
        };

        window.editShift = function(day, shiftIndex) {
            if (!user.isAdmin) {
                showNotification('‚ùå Admin access required', 'error');
                return;
            }
            // Find the shift
            const shift = (schedule[day] || [])[shiftIndex];
            if (!shift) {
                showNotification('‚ùå Shift not found', 'error');
                return;
            }
            // Show modal with shift info
            document.getElementById('editShiftModalBody').innerHTML = `
                <div><strong>Shift:</strong> ${day} ${formatTime(shift.start)} - ${formatTime(shift.end)}</div>
                <div style='margin-top:1rem;'>
                    <button class='btn btn-secondary' onclick="closeModal('editShiftModal')">Close</button>
                </div>
            `;
            document.getElementById('editShiftModal').style.display = 'block';
        };

        window.suggestAlternatives = function(day, shiftIndex) {
            if (!user.isAdmin) {
                showNotification('‚ùå Admin access required', 'error');
                return;
            }
            showNotification('üí° Alternative suggestions feature - Enhanced implementation coming soon!', 'info');
        };

        // Test Firebase connection
        async function testConnection() {
            try {
                console.log('Testing Firestore connection...');
                const workplacesSnapshot = await getDocs(collection(db, 'workplaces'));
                console.log(`‚úÖ Connected! Found ${workplacesSnapshot.size} workplaces in database.`);
                showNotification('‚úÖ Database connection successful', 'success');
            } catch (error) {
                console.error('‚ùå Connection test failed:', error);
                showNotification('‚ùå Database connection failed', 'error');
            }
        }

        testConnection();
    </script>
</body>
</html>